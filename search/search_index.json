{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wanna Res' Like You","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to Wanna Res Like You a Python-based super resolution tool designed to bring vintage photos into the high-definition domain. Advanced image processing techniques are used to enhances the quality and clarity of historical black-and-white and coloured images, making them vividly sharp and detailed. Perfect for reviving classic swing dance photos and other retro snapshots, Wanna Res Like You combines the charm of yesteryears with modern image resolution technology. Whether you're a swing dance enthusiast, a history buff, or simply a fan of old-time photography, this tool helps transform nostalgic moments into stunning, high-resolution visuals. Dive in and watch history come to life with unparalleled detail!</p> <p></p> <p>thank you chatGPT &lt;3</p> Objectives <p>The objectives of this project are:</p> <ul> <li>Manipulating super resolution methods,</li> <li>Learning to build an app in Python,</li> <li>Deploy this app.</li> </ul> Tech Specs <p>The technical specifications are:</p> <ul> <li>Create a CLI,</li> <li>Create an app,</li> <li>Create a tool to easily deploy the app.</li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"#interpolation-entrypoint","title":"Interpolation entrypoint","text":"<p>The interpolate feature allows users to apply different interpolation methods to images using OpenCV. This feature supports four interpolation methods: linear, nearest, cubic, and lanczos4. It can be used to scale images by specific x and y factors.</p> <p>This feature can be accessed via the interpolate entry point, which accepts an input image, a configuration file specifying the interpolation method and scaling factors, and generates an output image. Supported Interpolation Methods</p> <ul> <li>Linear interpolation: Suitable for simple resizing tasks with minimal image distortion.</li> <li>Nearest-neighbor interpolation: Fastest method, best for categorical images but can result in pixelated edges.</li> <li>Cubic interpolation: Produces smoother images with better quality when upscaling.</li> <li>Lanczos interpolation: A high-quality downsampling and upscaling method that preserves fine details in the image.</li> </ul> <p>See specific documentation for more detailled Interpolation feature</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Lorem ipsum</p>"},{"location":"#install-instructions","title":"Install Instructions","text":"<p>Lorem ipsum</p>"},{"location":"#setup","title":"Setup","text":"<p>Lorem ipsum</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Lorem ipsum</p>"},{"location":"#advanced-usage","title":"Advanced Usage","text":"<p>Lorem ipsum</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Guidelines on how to contribute</p>"},{"location":"#license","title":"License","text":"<p>Details of the project license</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Thanks to contributors and linked resources</p>"},{"location":"#contact-information","title":"Contact Information","text":"<p>How to get in touch or report issues</p>"},{"location":"#faq","title":"FAQ","text":"<ul> <li>Question 1: Answer</li> <li>Question 2: Answer</li> </ul>"},{"location":"Developers/components/","title":"Components","text":""},{"location":"Developers/components/#code-structure","title":"Code Structure","text":"<p>Explanation of the directory structure and core components.</p>"},{"location":"Developers/getting_started/","title":"Getting Started","text":""},{"location":"Developers/getting_started/#getting-started-for-developers","title":"Getting Started for Developers","text":"<ol> <li>Cloning the repository</li> <li>Setting up the development environment</li> </ol>"},{"location":"Developers/overview/","title":"Overview","text":""},{"location":"Developers/overview/#overview","title":"Overview","text":"<p>Architecture, technologies used, and project structure.</p>"},{"location":"Developers/workflow/","title":"Workflow","text":""},{"location":"Developers/workflow/#development-workflow","title":"Development Workflow","text":"<ol> <li>Building</li> <li>Testing</li> <li>Debugging</li> </ol>"},{"location":"Users/how_to_cli/","title":"CLI","text":""},{"location":"Users/how_to_deployement/","title":"Deploy App","text":""},{"location":"Users/how_to_local_app/","title":"Local App","text":""},{"location":"Users/usage/","title":"Users Guide","text":""},{"location":"Users/usage/#basic-usage","title":"Basic Usage","text":"<p>Lorem ipsum</p>"},{"location":"Users/usage/#advanced-usage","title":"Advanced Usage","text":"<p>Lorem ipsum</p>"},{"location":"Users/methods/frequency_based/","title":"Frequency based","text":"<ol> <li> <p>Frequency Domain Methods</p> <p>Fourier Transform-Based Methods:     Uses Fourier analysis to increase resolution by estimating high-frequency components (which correspond to fine details) in the image.     Can preserve details but may introduce artifacts if high-frequency components are incorrectly estimated. Wavelet Transform-Based Methods:     Wavelets allow multi-resolution analysis, which can be used to enhance image resolution at different scales.     Often used in combination with other techniques for better results.</p> </li> </ol>"},{"location":"Users/methods/interpolations/","title":"Interpolations","text":"<ol> <li> <p>Traditional Interpolation Methods</p> <p>Nearest Neighbor Interpolation:     Simplest form of interpolation that assigns the nearest pixel value to the new pixel.     Fast but can lead to blocky images, especially at higher scaling factors. Bilinear Interpolation:     Considers the closest 2x2 neighborhood of known pixel values surrounding the unknown pixel.     Averages the four nearest pixels, resulting in smoother images than nearest neighbor but can still blur edges. Bicubic Interpolation:     Considers the closest 4x4 neighborhood of known pixel values.     Produces smoother and sharper images than bilinear, with better edge preservation, but at a higher computational cost. Spline Interpolation:     Uses polynomial functions to interpolate between pixels, resulting in smooth curves.     Can preserve more detail and sharpness but can be computationally expensive.</p> </li> <li> <p>Edge-Directed Interpolation</p> <p>New Edge-Directed Interpolation (NEDI):     Aims to preserve edges by adjusting the interpolation process based on local edge directions.     Improves image sharpness, especially along edges, but can be more complex to implement. Iterative Back Projection (IBP):     Iteratively refines an image by comparing the downsampled image with the original lower-resolution image, focusing on maintaining edge detail.     This iterative process can produce high-quality images but is computationally intensive.</p> </li> </ol>"},{"location":"Users/methods/interpolations/#image-interpolation-feature","title":"Image Interpolation Feature","text":""},{"location":"Users/methods/interpolations/#overview","title":"Overview","text":"<p>The <code>interpolate</code> feature allows users to apply different interpolation methods to images using OpenCV. This feature supports four interpolation methods: linear, nearest, cubic, and lanczos4. It can be used to scale images by specific x and y factors.</p> <p>This feature can be accessed via the <code>interpolate</code> entry point, which accepts an input image, a configuration file specifying the interpolation method and scaling factors, and generates an output image.</p>"},{"location":"Users/methods/interpolations/#supported-interpolation-methods","title":"Supported Interpolation Methods","text":"<p>Linear interpolation: Suitable for simple resizing tasks with minimal image distortion. Nearest-neighbor interpolation: Fastest method, best for categorical images but can result in pixelated edges. Cubic interpolation: Produces smoother images with better quality when upscaling. Lanczos interpolation: A high-quality downsampling and upscaling method that preserves fine details in the image.</p>"},{"location":"Users/methods/interpolations/#usage","title":"Usage","text":"<p>The entry point for using this feature is <code>interpolate.py</code>. Below is the detailed usage information:</p> <pre><code>usage: interpolate.py [-h] --input INPUT --output OUTPUT [--overwrite OVERWRITE] --config CONFIG\n\noptions:\n  -h, --help            Show this help message and exit.\n  --input INPUT, -i INPUT\n                        Path to the input image.\n  --output OUTPUT, -o OUTPUT\n                        Path to the output image.\n  --overwrite OVERWRITE, -f OVERWRITE\n                        Flag to allow overwriting the output file.\n  --config CONFIG, -c CONFIG\n                        Path to the configuration file specifying interpolation parameters.\n</code></pre>"},{"location":"Users/methods/interpolations/#example","title":"Example","text":"<pre><code>python interpolate.py --input image.jpg --output resized_image.png --config config.json\n</code></pre> <p>In this example:</p> <ul> <li><code>--input</code> is the path to the source image to be interpolated.</li> <li><code>--output</code> is the path where the resized image will be saved.</li> <li><code>--config</code> points to a configuration file specifying the interpolation method and scaling factors (described below).</li> </ul>"},{"location":"Users/methods/interpolations/#input-image-example","title":"Input image example","text":""},{"location":"Users/methods/interpolations/#output-image-example","title":"Output image example","text":""},{"location":"Users/methods/learning_based/","title":"Learning based","text":"<ol> <li> <p>Learning-Based Methods</p> <p>Dictionary Learning:     Involves learning a dictionary of image patches from high-resolution images, which is then used to reconstruct a higher-resolution version of the input.     Can produce good results but requires a large amount of training data and is computationally expensive. Sparse Coding:     Similar to dictionary learning, it reconstructs images using a sparse representation of high-resolution image patches.     Effective for detailed textures and patterns but may struggle with smooth areas.</p> </li> <li> <p>Deep Learning-Based Methods</p> <p>Convolutional Neural Networks (CNNs):     Specialized CNN architectures (e.g., SRCNN, VDSR) are designed to learn the mapping from low-resolution to high-resolution images.     Typically produces superior results compared to traditional methods, especially in preserving fine details and textures. Generative Adversarial Networks (GANs):     Networks like SRGAN use a generator to create high-resolution images and a discriminator to differentiate between real and generated images, leading to more realistic outputs.     Can produce very sharp and realistic images but are difficult to train and may generate artifacts. Transformers:     More recent approaches involve using Transformer architectures to model long-range dependencies in the image, improving the quality of upscaled images.     These methods are cutting-edge but require substantial computational resources.</p> </li> <li> <p>Hybrid Methods</p> <p>Combination of Interpolation and Learning-Based Techniques:     Some methods combine traditional interpolation techniques with deep learning for refinement.     For instance, an initial upscaled image might be generated using bicubic interpolation, which is then refined using a CNN or GAN. Perceptual Loss-Based Methods:     Use loss functions that focus on perceptual similarity rather than pixel-wise accuracy (e.g., SSIM loss, perceptual loss based on VGG features).     Aims to generate images that are visually closer to the ground truth even if they are not pixel-perfect.</p> </li> <li> <p>Example-Based Super-Resolution</p> <p>Patch-Based Methods:     These methods upscale images by matching patches of low-resolution images with a database of high-resolution patches.     Requires a large database of examples and can be time-consuming but produces good results, especially for textures. Self-Example-Based Super-Resolution:     Uses the input image itself as the database by finding similar patches within the image, exploiting the self-similarity property of natural images.     Can work well for images with repetitive patterns.</p> </li> <li> <p>Reconstruction-Based Methods</p> <p>Total Variation Regularization:     Uses optimization techniques to minimize noise and enforce smoothness while preserving edges during upscaling.     Can reduce artifacts and improve edge sharpness but may smooth out fine details. Maximum a Posteriori (MAP) Estimation:     Formulates super-resolution as a probabilistic inference problem, finding the most probable high-resolution image given the low-resolution input.     Can incorporate various prior knowledge, such as smoothness or edge-preserving priors, to improve results.</p> </li> </ol>"}]}